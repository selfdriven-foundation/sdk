"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseAsset = exports.getFingerprint = exports.getAllMethodOptions = exports.getPaginationOptions = exports.getAdditionalParams = exports.handleError = exports.getHeaders = exports.validateOptions = void 0;
const cip14_js_1 = __importDefault(require("@emurgo/cip14-js"));
const config_1 = require("../config");
const validateOptions = (options) => {
    var _a, _b, _c;
    if (!options || (!options.customBackend && !options.projectId)) {
        throw Error('Missing customBackend or projectId option');
    }
    if (!options.projectId && !options.customBackend) {
        throw Error('Missing param projectId in options');
    }
    if (options.version && isNaN(options.version)) {
        throw Error('Param version is not a number');
    }
    if (options.requestTimeout && isNaN(options.requestTimeout)) {
        throw Error('Param requestTimeout is not a number');
    }
    if (options.retryDelay && isNaN(options.retryDelay)) {
        throw Error('Param retryDelay is not a number');
    }
    if (options.retryCount && isNaN(options.retryCount)) {
        throw Error('Param retryCount is not a number');
    }
    return {
        customBackend: options.customBackend,
        projectId: options.projectId,
        isTestnet: options.isTestnet,
        version: options.version || config_1.DEFAULT_API_VERSION,
        retry429: options.retry429 || true,
        retryCount: (_a = options.retryCount) !== null && _a !== void 0 ? _a : 20,
        retryDelay: (_b = options.retryDelay) !== null && _b !== void 0 ? _b : 1000,
        requestTimeout: (_c = options.requestTimeout) !== null && _c !== void 0 ? _c : 20000, // 20 seconds
    };
};
exports.validateOptions = validateOptions;
const getHeaders = (projectId, userAgent) => {
    if (!projectId) {
        return null;
    }
    const userAgentHeader = userAgent ? { 'User-Agent': userAgent } : null;
    return {
        project_id: projectId,
        ...userAgentHeader,
    };
};
exports.getHeaders = getHeaders;
const handleError = (error) => {
    var _a, _b, _c;
    if (error.code && error.errno) {
        // system errors such as -3008 ENOTFOUND
        return {
            errno: error.errno,
            code: error.code,
            message: error.message, // getaddrinfo ENOTFOUND cardano-testnet.blockfrost.io'
        };
    }
    if (error.response) {
        if (typeof error.response.data === 'object' &&
            ((_a = error.response.data) === null || _a === void 0 ? void 0 : _a.status_code)) {
            // response.data is already properly formatted
            return error.response.data;
        }
        // response.data may contain html output (eg. errors returned by nginx)
        const statusCode = error.response.status;
        const statusText = error.response.statusText;
        return {
            status_code: statusCode,
            message: `${statusCode}: ${statusText}`,
            error: statusText,
        };
    }
    else if (error.request) {
        const jsonError = error.toJSON();
        const message = (_b = jsonError.message) !== null && _b !== void 0 ? _b : 'Unexpected error while sending a request';
        const errorName = (_c = jsonError.error) !== null && _c !== void 0 ? _c : 'Error';
        return `${errorName}: ${message}`;
    }
    else if (error.message) {
        return error.message;
    }
    else {
        // we shouldn't get here, but just to be safe...
        return 'Unexpected error';
    }
};
exports.handleError = handleError;
const getAdditionalParams = (options) => {
    if (!options) {
        return {
            from: undefined,
            to: undefined,
        };
    }
    return {
        from: options.from || undefined,
        to: options.to || undefined,
    };
};
exports.getAdditionalParams = getAdditionalParams;
const getPaginationOptions = (options) => {
    if (!options) {
        return {
            page: config_1.DEFAULT_PAGINATION_PAGE_COUNT,
            count: config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT,
            order: config_1.DEFAULT_ORDER,
        };
    }
    return {
        page: options.page || config_1.DEFAULT_PAGINATION_PAGE_COUNT,
        count: options.count || config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT,
        order: options.order || config_1.DEFAULT_ORDER,
    };
};
exports.getPaginationOptions = getPaginationOptions;
const getAllMethodOptions = (options) => {
    if (!options) {
        return {
            batchSize: config_1.DEFAULT_BATCH_SIZE,
            order: config_1.DEFAULT_ORDER,
        };
    }
    return {
        batchSize: options.batchSize || config_1.DEFAULT_PAGINATION_PAGE_COUNT,
        order: options.order || config_1.DEFAULT_ORDER,
    };
};
exports.getAllMethodOptions = getAllMethodOptions;
const hexToString = (input) => {
    const hex = input.toString();
    let str = '';
    for (let n = 0; n < hex.length; n += 2) {
        str += String.fromCharCode(parseInt(hex.substr(n, 2), 16));
    }
    return str;
};
const getFingerprint = (policyId, assetName) => new cip14_js_1.default(Uint8Array.from(Buffer.from(policyId, 'hex')), Uint8Array.from(Buffer.from(assetName || '', 'hex'))).fingerprint();
exports.getFingerprint = getFingerprint;
const parseAsset = (hex) => {
    const policyIdSize = 56;
    const policyId = hex.slice(0, policyIdSize);
    const assetNameInHex = hex.slice(policyIdSize);
    const assetName = hexToString(assetNameInHex);
    const fingerprint = exports.getFingerprint(policyId, assetNameInHex);
    return {
        policyId,
        assetName,
        fingerprint,
    };
};
exports.parseAsset = parseAsset;
