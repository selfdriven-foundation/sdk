"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.accountsAddressesAssetsAll = exports.accountsAddressesAssets = exports.accountsAddressesAll = exports.accountsAddresses = exports.accountsRegistrationsAll = exports.accountsRegistrations = exports.accountsDelegationsAll = exports.accountsDelegations = exports.accountsMirsAll = exports.accountsMirs = exports.accountsWithdrawalsAll = exports.accountsWithdrawals = exports.accountsHistoryAll = exports.accountsHistory = exports.accountsRewardsAll = exports.accountsRewards = exports.accounts = void 0;
const config_1 = require("../../../config");
const utils_1 = require("../../../utils");
async function accounts(stakeAddress) {
    return new Promise((resolve, reject) => {
        this.axiosInstance(`${this.apiUrl}/accounts/${stakeAddress}`)
            .then(resp => {
            resolve(resp.data);
        })
            .catch(err => reject(utils_1.handleError(err)));
    });
}
exports.accounts = accounts;
async function accountsRewards(stakeAddress, pagination) {
    const paginationOptions = utils_1.getPaginationOptions(pagination);
    return new Promise((resolve, reject) => {
        this.axiosInstance(`${this.apiUrl}/accounts/${stakeAddress}/rewards`, {
            params: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.data);
        })
            .catch(err => reject(utils_1.handleError(err)));
    });
}
exports.accountsRewards = accountsRewards;
async function accountsRewardsAll(stakeAddress, allMethodOptions) {
    let page = 1;
    const count = config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT;
    const res = [];
    const options = utils_1.getAllMethodOptions(allMethodOptions);
    const getPromiseBundle = () => {
        const promises = [...Array(options.batchSize).keys()].map(i => this.accountsRewards(stakeAddress, {
            page: page + i,
            count,
            order: options.order,
        }));
        page += options.batchSize;
        return promises;
    };
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const promiseBundle = getPromiseBundle();
        const pages = await Promise.all(promiseBundle);
        for (const page of pages) {
            res.push(...page);
            if (page.length < config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT) {
                return res;
            }
        }
    }
}
exports.accountsRewardsAll = accountsRewardsAll;
async function accountsHistory(stakeAddress, pagination) {
    const paginationOptions = utils_1.getPaginationOptions(pagination);
    return new Promise((resolve, reject) => {
        this.axiosInstance(`${this.apiUrl}/accounts/${stakeAddress}/history`, {
            params: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.data);
        })
            .catch(err => reject(utils_1.handleError(err)));
    });
}
exports.accountsHistory = accountsHistory;
async function accountsHistoryAll(stakeAddress, allMethodOptions) {
    let page = 1;
    const count = config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT;
    const res = [];
    const options = utils_1.getAllMethodOptions(allMethodOptions);
    const getPromiseBundle = () => {
        const promises = [...Array(options.batchSize).keys()].map(i => this.accountsHistory(stakeAddress, {
            page: page + i,
            count,
            order: options.order,
        }));
        page += options.batchSize;
        return promises;
    };
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const promiseBundle = getPromiseBundle();
        const pages = await Promise.all(promiseBundle);
        for (const page of pages) {
            res.push(...page);
            if (page.length < config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT) {
                return res;
            }
        }
    }
}
exports.accountsHistoryAll = accountsHistoryAll;
async function accountsWithdrawals(stakeAddress, pagination) {
    const paginationOptions = utils_1.getPaginationOptions(pagination);
    return new Promise((resolve, reject) => {
        this.axiosInstance(`${this.apiUrl}/accounts/${stakeAddress}/withdrawals`, {
            params: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.data);
        })
            .catch(err => reject(utils_1.handleError(err)));
    });
}
exports.accountsWithdrawals = accountsWithdrawals;
async function accountsWithdrawalsAll(stakeAddress, allMethodOptions) {
    let page = 1;
    const count = config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT;
    const res = [];
    const options = utils_1.getAllMethodOptions(allMethodOptions);
    const getPromiseBundle = () => {
        const promises = [...Array(options.batchSize).keys()].map(i => this.accountsWithdrawals(stakeAddress, {
            page: page + i,
            count,
            order: options.order,
        }));
        page += options.batchSize;
        return promises;
    };
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const promiseBundle = getPromiseBundle();
        const pages = await Promise.all(promiseBundle);
        for (const page of pages) {
            res.push(...page);
            if (page.length < config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT) {
                return res;
            }
        }
    }
}
exports.accountsWithdrawalsAll = accountsWithdrawalsAll;
async function accountsMirs(stakeAddress, pagination) {
    const paginationOptions = utils_1.getPaginationOptions(pagination);
    return new Promise((resolve, reject) => {
        this.axiosInstance(`${this.apiUrl}/accounts/${stakeAddress}/mirs`, {
            params: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.data);
        })
            .catch(err => reject(utils_1.handleError(err)));
    });
}
exports.accountsMirs = accountsMirs;
async function accountsMirsAll(stakeAddress, allMethodOptions) {
    let page = 1;
    const count = config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT;
    const res = [];
    const options = utils_1.getAllMethodOptions(allMethodOptions);
    const getPromiseBundle = () => {
        const promises = [...Array(options.batchSize).keys()].map(i => this.accountsMirs(stakeAddress, {
            page: page + i,
            count,
            order: options.order,
        }));
        page += options.batchSize;
        return promises;
    };
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const promiseBundle = getPromiseBundle();
        const pages = await Promise.all(promiseBundle);
        for (const page of pages) {
            res.push(...page);
            if (page.length < config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT) {
                return res;
            }
        }
    }
}
exports.accountsMirsAll = accountsMirsAll;
async function accountsDelegations(stakeAddress, pagination) {
    const paginationOptions = utils_1.getPaginationOptions(pagination);
    return new Promise((resolve, reject) => {
        this.axiosInstance(`${this.apiUrl}/accounts/${stakeAddress}/delegations`, {
            params: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.data);
        })
            .catch(err => reject(utils_1.handleError(err)));
    });
}
exports.accountsDelegations = accountsDelegations;
async function accountsDelegationsAll(stakeAddress, allMethodOptions) {
    let page = 1;
    const count = config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT;
    const options = utils_1.getAllMethodOptions(allMethodOptions);
    const res = [];
    const getPromiseBundle = () => {
        const promises = [...Array(options.batchSize).keys()].map(i => this.accountsDelegations(stakeAddress, {
            page: page + i,
            count,
            order: options.order,
        }));
        page += options.batchSize;
        return promises;
    };
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const promiseBundle = getPromiseBundle();
        const pages = await Promise.all(promiseBundle);
        for (const page of pages) {
            res.push(...page);
            if (page.length < config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT) {
                return res;
            }
        }
    }
}
exports.accountsDelegationsAll = accountsDelegationsAll;
async function accountsRegistrations(stakeAddress, pagination) {
    const paginationOptions = utils_1.getPaginationOptions(pagination);
    return new Promise((resolve, reject) => {
        this.axiosInstance(`${this.apiUrl}/accounts/${stakeAddress}/registrations`, {
            params: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.data);
        })
            .catch(err => reject(utils_1.handleError(err)));
    });
}
exports.accountsRegistrations = accountsRegistrations;
async function accountsRegistrationsAll(stakeAddress, allMethodOptions) {
    let page = 1;
    const count = config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT;
    const res = [];
    const options = utils_1.getAllMethodOptions(allMethodOptions);
    const getPromiseBundle = () => {
        const promises = [...Array(options.batchSize).keys()].map(i => this.accountsRegistrations(stakeAddress, {
            page: page + i,
            count,
            order: options.order,
        }));
        page += options.batchSize;
        return promises;
    };
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const promiseBundle = getPromiseBundle();
        const pages = await Promise.all(promiseBundle);
        for (const page of pages) {
            res.push(...page);
            if (page.length < config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT) {
                return res;
            }
        }
    }
}
exports.accountsRegistrationsAll = accountsRegistrationsAll;
async function accountsAddresses(stakeAddress, pagination) {
    const paginationOptions = utils_1.getPaginationOptions(pagination);
    return new Promise((resolve, reject) => {
        this.axiosInstance(`${this.apiUrl}/accounts/${stakeAddress}/addresses`, {
            params: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.data);
        })
            .catch(err => reject(utils_1.handleError(err)));
    });
}
exports.accountsAddresses = accountsAddresses;
async function accountsAddressesAll(stakeAddress, allMethodOptions) {
    let page = 1;
    const count = config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT;
    const res = [];
    const options = utils_1.getAllMethodOptions(allMethodOptions);
    const getPromiseBundle = () => {
        const promises = [...Array(options.batchSize).keys()].map(i => this.accountsAddresses(stakeAddress, {
            page: page + i,
            count,
            order: options.order,
        }));
        page += options.batchSize;
        return promises;
    };
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const promiseBundle = getPromiseBundle();
        const pages = await Promise.all(promiseBundle);
        for (const page of pages) {
            res.push(...page);
            if (page.length < config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT) {
                return res;
            }
        }
    }
}
exports.accountsAddressesAll = accountsAddressesAll;
async function accountsAddressesAssets(stakeAddress, pagination) {
    const paginationOptions = utils_1.getPaginationOptions(pagination);
    return new Promise((resolve, reject) => {
        this.axiosInstance(`${this.apiUrl}/accounts/${stakeAddress}/addresses/assets`, {
            params: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.data);
        })
            .catch(err => reject(utils_1.handleError(err)));
    });
}
exports.accountsAddressesAssets = accountsAddressesAssets;
async function accountsAddressesAssetsAll(stakeAddress, allMethodOptions) {
    let page = 1;
    const count = config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT;
    const res = [];
    const options = utils_1.getAllMethodOptions(allMethodOptions);
    const getPromiseBundle = () => {
        const promises = [...Array(options.batchSize).keys()].map(i => this.accountsAddressesAssets(stakeAddress, {
            page: page + i,
            count,
            order: options.order,
        }));
        page += options.batchSize;
        return promises;
    };
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const promiseBundle = getPromiseBundle();
        const pages = await Promise.all(promiseBundle);
        for (const page of pages) {
            res.push(...page);
            if (page.length < config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT) {
                return res;
            }
        }
    }
}
exports.accountsAddressesAssetsAll = accountsAddressesAssetsAll;
